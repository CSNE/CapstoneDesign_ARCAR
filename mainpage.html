<!DOCTYPE html>
<html>
<head>
	<title>ARCAR Web Renderer</title>
	</style>
</head>
<body style="margin:0;">
	<canvas id="ar_canvas"> </canvas>
	
	<script type="module">
		import * as THREE from "https://cdn.skypack.dev/three@0.132.2";
		import { OrbitControls } from "https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js";
		
		const scene = new THREE.Scene();

		// Lights
		const alight = new THREE.AmbientLight(0xFFFFFF, 0.5);
		scene.add(alight);


		// Renderer
		const w=480;
		const h=270;
		const renderer = new THREE.WebGLRenderer( { antialias: true, canvas:ar_canvas} );
		//renderer.setSize(w,h);
		renderer.setAnimationLoop( animation );

		// Camera controls
		const camera = new THREE.PerspectiveCamera( 60, w/h, 0.001, 1000 );
		const controls = new OrbitControls( camera, renderer.domElement );
		controls.target=new THREE.Vector3( 0, 0, -3 );
		camera.position.set( 0, 0, 0 );
		controls.update();
		
		window.addEventListener('resize', makeCanvasFull);
		window.addEventListener('load', makeCanvasFull);

		function makeCanvasFull(){
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}


		// Anim Loop
		function animation( time ) {
			controls.update();
			renderer.render( scene, camera );
		}
		
		
		
		function request(location,succ,fail){
			var xhr=new XMLHttpRequest();
			xhr.open("GET",location);
			xhr.addEventListener("load",function(e){
				if (xhr.status==200) succ(xhr.responseText);
				else fail(xhr.status);
			});
			xhr.addEventListener("error",function(e){
				fail(e);
			});
			xhr.send();
		}
		
		// Function for creating objects from the python server
		const loader = new THREE.TextureLoader();
		var object_meshes=[];
		function setObjects(objs){
			// Remove all objects first
			for (var i=0;i<object_meshes.length;i++){
				scene.remove(object_meshes[i])
			}
			object_meshes=[];
			
			// Add objects
			for (var i=0;i<objs.length;i++){
				var obj=objs[i];
				
				const objGeom = new THREE.PlaneGeometry(obj["sizeX"], obj["sizeY"]);
				
				const objMat= new THREE.MeshBasicMaterial();
				objMat.side=THREE.DoubleSide;
				objMat.color.setRGB(1,1,1);
				objMat.map=loader.load(obj["texture"]);
				
				const objMesh = new THREE.Mesh(objGeom,objMat);
				objMesh.position.x=obj["coordX"];
				objMesh.position.y=obj["coordY"];
				objMesh.position.z=-obj["coordZ"];
				
				scene.add(objMesh);
				object_meshes.push(objMesh);
			}
			
		}

		// Periodically fetch objects from python server
		function getObjData(){
			request(
				"/objects",
				function(resp){setObjects(JSON.parse(resp));},
				function(){})
		}
		
		function buildWireMesh(pointlist){
			const geometry = new THREE.BufferGeometry();
			
			let positions=[];
			for (var i in pointlist){
				var pt=pointlist[i];
				positions.push(pt[0]);
				positions.push(pt[1]);
				positions.push(pt[2]);
				//console.log(pt);
			}
			const vertices = new Float32Array(positions);
			//console.log(vertices);

			// itemSize = 3 because there are 3 values (components) per vertex
			geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
			//const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
			//const mesh = new THREE.Mesh( geometry, material );
			geometry.computeBoundingSphere();
			//const wireframe = new THREE.WireframeGeometry( geometry );

			//const line = new THREE.LineSegments( wireframe );
			//line.material.depthTest = false;
			//line.material.opacity = 0.25;
			//line.material.transparent = true;
			
			const material = new THREE.LineBasicMaterial();
			material.color=new THREE.Color(1,0,0);
			var line = new THREE.Line( geometry, material );
			
			return line;
		}
		
		var wire_meshes=[];
		function setSeg3D(s3d){
			// Remove all objects first
			for (var i=0;i<wire_meshes.length;i++){
				scene.remove(wire_meshes[i])
			}
			wire_meshes=[];
			
			for (var i in s3d){
				let name = s3d[i]["name"];
				let pointlist= s3d[i]["pointlist"];
				let wm=buildWireMesh(pointlist);
				scene.add(wm);
				wire_meshes.push(wm);
			}
		}
		
		function updateSeg3D(){
			request(
				"seg3d",
				function(resp){setSeg3D(JSON.parse(resp));},
				function(){});
		}
		
		
		var object_points=[];
		var pointCubeSize=0.02;
		function setPointCloud(pointList){
			for (var i=0;i<object_points.length;i++){
				scene.remove(object_points[i])
			}
			object_points=[];
			//console.log(pointList);
			// Add objects
			for (var i=0;i<pointList.length;i++){
				var pnt=pointList[i];

				//console.log(pnt);

				const objGeom = new THREE.BoxGeometry(pointCubeSize,pointCubeSize,pointCubeSize);

				const objMat= new THREE.MeshBasicMaterial();
				//objMat.side=THREE.DoubleSide;
				const objMesh = new THREE.Mesh(objGeom,objMat);
				objMat.color.setRGB(pnt["r"],pnt["g"],pnt["b"]);
				objMesh.position.x=pnt["x"];
				objMesh.position.y=pnt["y"];
				objMesh.position.z=pnt["z"];

				scene.add(objMesh);
				object_points.push(objMesh);
			}
		}
		
		function updatePC(){
			request(
				"pointcloud",
				function(resp){setPointCloud(JSON.parse(resp));},
				function(){});
		}
		

		
		
		var last_update_flag;
		function updateCheck(){
			request(
				"/update_flag",
				function(resp){
					if (resp != last_update_flag){
						console.log("Updating "+resp);
						last_update_flag=resp;
						//getObjData();
						updateSeg3D();
						updatePC();
					}
				},
				function(e){}
			);
		}
		setInterval(updateCheck,50);
		
		

	</script>
	
	
	</body>
</html>
